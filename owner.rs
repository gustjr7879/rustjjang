fn main() {
    let s = String::from("hello"); // String 타입 아래에 from함수를 사용해서 특정지어줌.
    let mut ss = String::from("hello");
    ss.push_str(", world!");
    println!("{}",ss);
    let s1 = s;
    //println!("{}",s); 이렇게 하면 s가 drop이 된 상태이고 그러기 때문에 없다고 가정한다.
    println!("{}",s1);
    let s2 = s1.clone();
    println!("s1 = {}, s2 = {}",s1,s2);
    // 여기까지 str같은 것들이 복사가 안되고 drop되는 과정을 보여줌
    let x = 5;
    let y = x;
    println!("x = {}, y = {}",x,y);
    //여기까지 정수형이 쉽게 복사되는것을 보여줌
    takes_ownership(s1);
    //println!("{}",s1); str와 같은 타입은 스코프가 벗어나지면 drop이 호출되기 떄문에 이 takes_ownership에서 사용되고 drop되었기 때문에 더이상 불러올 수 없다.
    //만약에 불러오고 싶다면 s1을 takes_ownership에 넣을 때 .clone()으로 넣어야함.
    makes_copy(x);
    println!("test {}",x); // i32와 같은 타입은 상관없음.

    let sss = gives_ownership();
    println!("{}",sss);
    let sss2 = String::from("hello");
    let sss3 = takes_and_give_back(sss2);
    //println!("{}",sss2); 이 상황에서는 sss2가 takes_and_give_back에서 drop되어서 사라졌고 sss3만 남아있음 
    println!("{}",sss3);
}
fn takes_ownership(some_string: String){
    println!("{}",some_string);
}
fn makes_copy(some_int: i32){
    println!("{}",some_int);
}
fn gives_ownership() -> String {
    let some_string = String::from("hello3");
    some_string
}
fn takes_and_give_back(a_string:String) -> String{
    a_string
}
//소유권 (Ownership)은 러스트가 가비지 콜렉터 없이 메모리 안정성 보장을 하게 해준다. 몇몇 언어는 프로그램이 실행될 때 더이상 사용하지 않는 메모리를 찾는 가비지 콜렉터를 가지고 있다.
//또 다른 언어들에서는 프로그래머가 직접 명시적으로 메모리를 할당하고 해제해야한다. 러스트는 다르게 접근한다. 
//그 전에 스택과 힙의 차이를 알아야한다. 스택은 잘안다. 데이터를 추가하는것을 스택에 push하기라고 하고 제거하는것을 스택에서 pop하기 라고 한다.
//스택은 새로운 데이터를 넣어두기 위한 공간이나 가져올 공간을 검색할 필요가 전혀 없는데, 그 공간이 무조건 스택의 꼭대기라서 그렇다. 또한 스택에 있는 데이터의 크기는 고정되어있다
//컴파일 타임에 크기가 결정되어 있지 않거나 크기가 변경될 수 있는 데이터를 위해서는 힙에 저장해야한다. 데이터를 힙에 넣을때는 저장할 공간이 있는지 물어본다.
//운영체제에서는 충분히 커다란 힙 안에 빈 지점을 찾아서 사용중이라고 표시하고 그 포인터를 우리에게 알려준다. 이 과정을 힙 공간 할당하기 라고 하고 보통 할당하기 라고 한다.
//따라서 힙에 접근하는 것은 포인터들을 따라가야하기 때문에 느리다. 코드의 어느 부분이 힙의 어떤 데이터를 사용하는지 추적하는것, 힙의 중복된 데이터 양을 최소화하는것, 그리고 힙에서 사용하지 않는것을 제거하는것
//이 모두가 소유권과 관계된 문제들이다.
//러스트의 소유권 규칙을 알아보자 
//1. 러스트의 각각의 값(value)는 해당 값의 오너(owner)라고 불리우는 변수를 가지고 있다.
//2. 한번에 딱 하나의 오너만 존재할 수 있다.
//3. 오너가 스코프 밖으로 벗어날 때 값은 버려진다(dropped) -> 변수의 스코프란 프로그램 내에서 아이템이 유효함을 표시하기 위한 범위이다.
// let s = "hello"; 라는 변수가 있을 때 만약에 {let s = "hello";}로 범위 표시가 되어있다면, 이 범위가 스코프가 된다. s는 저 {}안에서만 유효하다.

//code 설명 : 가변 변수 ss를 선언해주고 String타입으로 하되 ("hello")에서 스트링을 가져온다. 따라서 ss는 hello가 된다. 또한 여기에 push_str(", world!")를 해서 ss를 변경시킨다.
//스트링은 변할 수 있는데 그냥 let s = "hello"와 같은 스트링리터럴은 변할 수 없다. 그러기 때문에 String::from("hello")와 같이 사용하는 것이다.
//가비지 콜렉터가 제때 반납해준다면 정말 다행이겠지만, 만약에 스코프를 지정해주고 그 안에서만 사용하고 반납하게 할 수 있다. {}로 범위를 지정해주면 된다.
//또한 복사를 하게되면 자동으로 이전 변수는 drop하게 된다 즉 복사를 쉽게 할 수 없게 해놨다는 것이다. 그대로 가져다가 사용할 수 없다. 복사를 하려면 .clone()을 사용해줘야한다.
//하지만 스택에는 쉽게 복사할 수 있다. 정수형과 같이 컴파일 타임에 결정되어있는 크기의 타입은 스택에 모두 저장되기 때문에 복사할 수 있다.(u32와 같은 정수형타입),boolean타입, f64 부동소수점, 이런 타입으로 된 튜플

//반환값과 스코프, 값의 반환 또한 소유권을 이동시킨다. 반환하는 값에 소유권이 있다고 생각하자. 만약에 소유권을 가진 변수가 어떤 함수에 들어가서 반환이 되면 기존 변수는 drop처리되고 나온 변수가 소유권을 가지고 있다.
